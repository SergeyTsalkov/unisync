
rsync --archive --delete --exclude='.git' --exclude='unisync' /Users/sergey/unisync/ sergey@51.79.19.179:unisync

{
  local: /path/to/stuff
  remote: /path/to/stuff
  username: (required for ssh, ignored for directtls)
  host: [ip]
  port: (defaults to 22 for ssh, required for directtls)
  method: ssh | nativessh | directtls
  prefer: local | remote | newer | older (default: newer)
  cache: filename (default: [name].cache)
}

example:
  unisync ~/localpath user@host:remotepath/
  unisync myhost.json
  unisync -start myhost.json (run in background)
  unisync -stop myhost.json (stop running in background)
  unisync -stopall
  unisync -status (list jobs running in background)


SYNC PROGRESS REPORT
  node.progress -- general progress channel? (can also get info from PROGRESS packets from server)

  log.Println("<- receiving file")
  go showprogress(node.progress, done) -- render progress bar until done channel is closed




WHEN TO PING/PONG?
  Option 1:
    - when client is idle, start 1 minute timer; when timer fires, send PING and waitFor("PONG")
    - when client is idle, we have a 1m+timeout timer that will kill the connection
    - when server is idle, it has a 1m+timeout timer that will kill the connection; it resets every time we handle a packet (including PING)
    Problem:
    - connetion could hang while we're e.g. receiving a file




TODO:
  - dump server connection on error, auto reconect and retry
  - handle timeouts: on connect (regardless of method); use PING once a minute to catch disconects at any point
  - nativessh method
  - direct / directtls methods
  - work without config file, from command line; choose cache name intelligently
  - detect CHMOD and sync

  

  - progress bar, nicer-looking console progress on sync
    maybe send PROGRESS {path: bigfile.txt, progress: 5} every second if receiving file takes more than 1 second
    will need to send size as part of PUSH so other side knows expected file size (even if it's not guaranteed)
    

  - client should delete any .unisync-tmp files on abrupt exit, including if user hits Ctrl+C


       



